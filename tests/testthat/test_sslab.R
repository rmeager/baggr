# RM: for now, the sslab gen and fit tests are in this script
# Feel free to kill/move as needed


# This data was generated by RM using the following parameters
# mu <- c(1,2)
# tau <- c(1,0)
# sd_mu <- c(1,2)
# sd_tau <- c(0.5,1)
# sigma_control <- c(1,1)
# sd_sigma_control <- c(1,1)
# sigma_TE <- c(1,1)
# sd_sigma_TE <- c(0.5,0.5)
# K <- 5
# N <- K*300
# x <- data.frame( rep(1,N), rbinom(N,1,0.5) )
# site <- rep(seq(1:K),each = N/K)
# beta <- matrix(c(0.5,0,0,0.5,-0.5,0), 3,2)
# sigma <- matrix(rep(0.5,6),3,2)

# A note on the above: the reported beta_ks will differ from the generative params
# because the new model enforces sigma = 0 for the Mth category per discussions on basecamp
# right now i'm just doing a test of the literal stan execution

data(data_spike)
data <- data_spike
N <-  length(data_spike$profit)

cat <- rep(NA,N) # storage
for(i in 1:N){
  if(data$profit[i] < 0){ cat[i] <- 1  }
  else if(identical(data$profit[i],0)){cat[i] <- 2}
  else{cat[i] <- 3}
}

data <- data.frame(data, cat)
data_split <- list( data[cat==1,],data[cat==3,])

# create the data input
sslab_test_data <- list( M = 3,
                         N = length(data$profit),
                         P = 2, # dimensionality of X and hence of kappa param in logit
                         K = length(unique(data$site)),
                         pooling_type = 0, # 0 if none, 1 if partial, 2 if full
                         cat = data$cat,
                         N_neg = length(data$profit[data$cat ==1]),
                         N_pos = length(data$profit[data$cat ==3]),
                         x = data[,c("constant", "treatment")],
                         site = data$site,
                         treatment_neg = data$treatment[data$cat ==1],
                         treatment_pos = data$treatment[data$cat ==3],
                         site_neg = data$site[data$cat ==1],
                         site_pos = data$site[data$cat ==3],
                         y_neg = -data$profit[data$cat ==1],
                         y_pos = data$profit[data$cat ==3],
                         prior_control_fam = 1,
                         prior_hypermean_fam = 1,
                         prior_scale_control_fam = 1,
                         prior_scale_fam = 1,
                         prior_control_sd_fam = 1,
                         prior_hypersd_fam = 1,
                         prior_scale_control_sd_fam = 1,
                         prior_scale_sd_fam = 1,
                         prior_kappa_fam = 1,
                         prior_kappa_sd_fam = 1,
                         prior_control_val = c(0,100,0),
                         prior_hypermean_val = c(0,100,0),
                         prior_scale_control_val = c(0,5,0),
                         prior_scale_val = c(0,5,0),
                         prior_kappa_val = c(0,5,0),
                         prior_control_sd_val = c(0,5,0),
                         prior_hypersd_val = c(0,5,0),
                         prior_scale_control_sd_val = c(0,5,0),
                         prior_scale_sd_val = c(0,5,0),
                         prior_kappa_sd_val =  c(0,5,0)
) # thus finishes the data entry jesus christ


options(mc.cores = 4)
rstan_options(auto_write = TRUE)
sm <- stan_model("src/stan_files/sslab.stan")

stan_fit <- sampling(sm,
                     iter = 2000, chains = 4, data = sslab_test_data)
print(stan_fit)


# maybe just do a coverag test of the partial pooling model since that is what is simulated
# maybe we need to re-simulate with the right kappa parameter though
