# RM: for now, the sslab gen and fit tests are in this script
# Feel free to kill/move as needed


# This data was generated by RM using the following parameters
# Uncommenting only those parts I need for the simulation test later
mu <- c(1,2)
tau <- c(1,0)
sd_mu <- c(1,2)
sd_tau <- c(0.5,1)
sigma_control <- c(1,1)
sd_sigma_control <- c(1,1)
sigma_TE <- c(1,1)
sd_sigma_TE <- c(0.5,0.5)
K <- 5
N <- K*300
# x <- data.frame( rep(1,N), rbinom(N,1,0.5) )
# site <- rep(seq(1:K),each = N/K)
# beta <- matrix(c(0.5,0,0,0.5,-0.5,0), 3,2)
# sigma <- matrix(rep(0.5,6),3,2)

# A note on the above: the reported beta_ks will differ from the generative params
# because the new model enforces sigma = 0 for the Mth category per discussions on basecamp
# right now i'm just doing a test of the literal stan execution

data(data_spike)
data <- data_spike
N <-  length(data_spike$profit)

cat <- rep(NA,N) # storage
for(i in 1:N){
  if(data$profit[i] < 0){ cat[i] <- 1  }
  else if(identical(data$profit[i],0)){cat[i] <- 2}
  else{cat[i] <- 3}
}

data <- data.frame(data, cat)
data_split <- list( data[cat==1,],data[cat==3,])

# create the data input
sslab_test_data <- list( M = 3,
                         N = length(data$profit),
                         P = 2, # dimensionality of X and hence of kappa param in logit
                         K = length(unique(data$site)),
                         pooling_type = 1, # 0 if none, 1 if partial, 2 if full
                         cat = data$cat,
                         N_neg = length(data$profit[data$cat ==1]),
                         N_pos = length(data$profit[data$cat ==3]),
                         x = data[,c("constant", "treatment")],
                         site = data$site,
                         treatment_neg = data$treatment[data$cat ==1],
                         treatment_pos = data$treatment[data$cat ==3],
                         site_neg = data$site[data$cat ==1],
                         site_pos = data$site[data$cat ==3],
                         y_neg = -data$profit[data$cat ==1],
                         y_pos = data$profit[data$cat ==3],
                         prior_control_fam = 1,
                         prior_hypermean_fam = 1,
                         prior_scale_control_fam = 1,
                         prior_scale_fam = 1,
                         prior_control_sd_fam = 1,
                         prior_hypersd_fam = 1,
                         prior_scale_control_sd_fam = 1,
                         prior_scale_sd_fam = 1,
                         prior_kappa_fam = 1,
                         prior_kappa_sd_fam = 1,
                         prior_control_val = c(0,100,0),
                         prior_hypermean_val = c(0,100,0),
                         prior_scale_control_val = c(0,5,0),
                         prior_scale_val = c(0,5,0),
                         prior_kappa_val = c(0,5,0),
                         prior_control_sd_val = c(0,5,0),
                         prior_hypersd_val = c(0,5,0),
                         prior_scale_control_sd_val = c(0,5,0),
                         prior_scale_sd_val = c(0,5,0),
                         prior_kappa_sd_val =  c(0,5,0)
) # thus finishes the data entry jesus christ


options(mc.cores = 4)
rstan_options(auto_write = TRUE)
sm <- stan_model("src/stan_files/sslab.stan")

stan_fit <- sampling(sm,
                     iter = 500, chains = 4, data = sslab_test_data)
print(stan_fit)
fit_summary <- summary(stan_fit)$summary

# now, a coverage test of the partial pooling model since that is what is simulated
# we are not testing on kappa because we'd have to renormalize and I do not want to
# instead we will check on the others

S <- 50
param_names <- rownames(fit_summary)[1:16]
mse <- matrix(NA, length(param_names),S)
calibration_check_95 <- matrix(NA, length(param_names),S)
calibration_check_50 <- matrix(NA, length(param_names),S)

true_params <- c(mu, tau, sd_mu, sd_tau,
                 sigma_control, sigma_TE, sd_sigma_control, sd_sigma_TE)
for(s in 1:S){
  stan_fit <- sampling(sm,
                       iter = 800, chains = 4, data = sslab_test_data)
  fit_summary <- summary(stan_fit)$summary
for(i in 1:length(param_names)){
  mse[i,s] <- (fit_summary[param_names[i], "mean"] - true_params[i])^2
  calibration_check_50[i,s] <- isTRUE(fit_summary[param_names[i], "25%"] <= true_params[i] &
                                        fit_summary[param_names[i], "75%"] >= true_params[i] )
  calibration_check_95[i,s] <- isTRUE(fit_summary[param_names[i], "2.5%"] <= true_params[i] &
                                        fit_summary[param_names[i], "97.5%"] >= true_params[i] )

} # closes forloop indexed by i

} # closes forloop indexed by s


 # now make a table that has parameters on rows and performance metrics on columns

sim_table <- data.frame(param_names,
                        apply(mse,1,mean),
                        apply(calibration_check_50,1,mean),
                        apply(calibration_check_95,1,mean))

colnames(sim_table) <- c("Parameter", "MSE", "50% Interval Coverage", "95% Interval Coverage")
# pdf("output/coverage_probs_sslab.pdf", width = 8, height = 3)
library("gridExtra")
 grid.table(sim_table, rows = NULL)
# dev.off()


 # This is not amazing performance on the 50%, but very good on the 95%

